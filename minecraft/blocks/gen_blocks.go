//go:build generate
// +build generate

// gen_blocks.go generates item information.
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"text/template"

	"github.com/iancoleman/strcase"
)

const (
	version = "1.8"
	infoURL = "https://raw.githubusercontent.com/PrismarineJS/minecraft-data/master/data/pc/" + version + "/blocks.json"
	//language=gohtml
	itemTmpl = `// Code generated by gen_blocks.go DO NOT EDIT.
// Package item stores information about blocks in Minecraft.
package blocks
// ID describes the numeric ID of an item.
type ID uint32
// Block describes information about a type of item.
type Block struct {
	ID          ID
	DisplayName string
	Name        string
	StackSize   uint
	Hardness    float64
	Diggable    bool
	Transparent bool
}
var (
	{{- range .}}
	{{.CamelName}} = Block{
		ID: {{ .ID }},
		DisplayName: "{{ .DisplayName }}",
		Name: "{{ .Name }}",
		StackSize: {{ .StackSize }},
		Hardness: {{ .Hardness }},
		Diggable: {{ .Diggable }},
		Transparent: {{ .Transparent }},
	}{{end}}
)
// ByID is an index of minecraft blocks by their ID.
var ByID = map[ID]*Block{ {{ range . }}
	{{ .ID }}: &{{ .CamelName }},{{ end }}
}`
)

type Block struct {
	ID          uint32  `json:"id"`
	CamelName   string  `json:"-"`
	DisplayName string  `json:"displayName"`
	Name        string  `json:"name"`
	StackSize   uint    `json:"stackSize"`
	Hardness    float64 `json:"hardness"`
	Diggable    bool    `json:"diggable"`
	Transparent bool    `json:"transparent"`
}

func downloadInfo() ([]*Block, error) {
	resp, err := http.Get(infoURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var data []*Block
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return nil, err
	}
	for _, d := range data {
		d.CamelName = strcase.ToCamel(d.Name)
	}
	return data, nil
}

//go:generate go run $GOFILE
//go:generate go fmt blocks.go
func main() {
	fmt.Println("generating blocks.go")
	items, err := downloadInfo()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	f, err := os.Create("blocks.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	if err := template.Must(template.New("").Parse(itemTmpl)).Execute(f, items); err != nil {
		panic(err)
	}
}
